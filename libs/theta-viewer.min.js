/*!
 * ThetaViewer - Modernized 2025 version (for Android Chrome)
 * Rewritten and optimized by ChatGPT Frontend Engineer
 * Requires: Three.js, jQuery
 */

(function ($) {
  "use strict";

  /**
   * 建立 ThetaViewer 實例
   * @param {HTMLElement|jQuery} element - 容器元素
   * @param {string} image_url - 全景圖網址
   */
  async function createThetaViewer(element, image_url) {
    const $el = $(element);
    const container = $el.get(0);

    // === 基本防呆：確保容器有大小 ===
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    if (width === 0 || height === 0) {
      console.warn("容器尺寸為 0，延遲初始化 ThetaViewer...");
      await new Promise((r) => setTimeout(r, 200));
      width = container.clientWidth || window.innerWidth;
      height = container.clientHeight || window.innerHeight;
    }

    // === 初始化 Three.js ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    if (renderer.setPixelRatio) {
      renderer.setPixelRatio(window.devicePixelRatio);
    }
    renderer.setSize(width, height);
    container.innerHTML = "";
    container.appendChild(renderer.domElement);

    // === 載入貼圖（含 Android 相容設定）===
    const loader = new THREE.TextureLoader();
    loader.setCrossOrigin("anonymous");

    const texture = await new Promise((resolve, reject) => {
      loader.load(
        image_url,
        (tex) => {
          if (!tex.image || tex.image.width === 0 || tex.image.height === 0) {
            reject(new Error("貼圖寬高為 0"));
            return;
          }
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.generateMipmaps = false;
          resolve(tex);
        },
        undefined,
        (err) => reject(err)
      );
    }).catch((err) => {
      console.error("圖片載入失敗：", err);
      alert("圖片載入失敗：" + image_url);
      return null;
    });

    if (!texture) return;

    // === 建立球體全景 ===
    const geometry = new THREE.SphereGeometry(500, 60, 40);
    geometry.scale(-1, 1, 1);

    const material = new THREE.MeshBasicMaterial({ map: texture });
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    camera.position.set(0, 0, 0);

    // === 拖曳控制 ===
    let isDragging = false;
    let lon = 0, lat = 0, phi = 0, theta = 0;
    let startX = 0, startY = 0;

    const getEventClientX = (e) =>
      e.clientX !== undefined ? e.clientX : (e.touches ? e.touches[0].clientX : 0);
    const getEventClientY = (e) =>
      e.clientY !== undefined ? e.clientY : (e.touches ? e.touches[0].clientY : 0);

    function onPointerDown(e) {
      isDragging = true;
      startX = getEventClientX(e);
      startY = getEventClientY(e);
      if (e.pointerId && container.setPointerCapture) container.setPointerCapture(e.pointerId);
    }

    function onPointerMove(e) {
      if (!isDragging) return;
      e.preventDefault();
      const dx = getEventClientX(e) - startX;
      const dy = getEventClientY(e) - startY;
      startX = getEventClientX(e);
      startY = getEventClientY(e);
      lon -= dx * 0.1;
      lat += dy * 0.1;
      lat = Math.max(-85, Math.min(85, lat));
    }

    function onPointerUp(e) {
      isDragging = false;
      if (e.pointerId && container.releasePointerCapture)
        container.releasePointerCapture(e.pointerId);
    }

    container.addEventListener("pointerdown", onPointerDown);
    container.addEventListener("pointermove", onPointerMove);
    container.addEventListener("pointerup", onPointerUp);
    container.addEventListener("pointercancel", onPointerUp);

    // touch fallback
    container.addEventListener("touchstart", onPointerDown, { passive: false });
    container.addEventListener("touchmove", onPointerMove, { passive: false });
    container.addEventListener("touchend", onPointerUp);
    container.addEventListener("touchcancel", onPointerUp);

    // === 滾輪縮放 ===
    container.addEventListener("wheel", (e) => {
      e.preventDefault();
      camera.fov += e.deltaY * 0.05;
      camera.fov = Math.max(30, Math.min(100, camera.fov));
      camera.updateProjectionMatrix();
    });

    // === Resize 事件（含 debounce）===
    let resizeTimer = null;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        const newW = container.clientWidth || window.innerWidth;
        const newH = container.clientHeight || window.innerHeight;
        renderer.setSize(newW, newH);
        camera.aspect = newW / newH;
        camera.updateProjectionMatrix();
      }, 150);
    });

    // === 動畫循環 ===
    function animate() {
      requestAnimationFrame(animate);
      const degToRad = (THREE.MathUtils && THREE.MathUtils.degToRad) || THREE.Math.degToRad;
      phi = degToRad(90 - lat);
      theta = degToRad(lon);
      const x = Math.sin(phi) * Math.cos(theta);
      const y = Math.cos(phi);
      const z = Math.sin(phi) * Math.sin(theta);
      camera.lookAt(new THREE.Vector3(x, y, z));
      renderer.render(scene, camera);
    }

    animate();
  }

  // === jQuery 插件包裝 ===
  $.fn.createThetaViewer = function (image_url) {
    return this.each(function () {
      createThetaViewer(this, image_url);
    });
  };
})(jQuery);
