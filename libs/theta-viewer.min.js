/*!
 * ThetaViewer - Modernized 2025 version (for Android Chrome)
 * Rewritten by ChatGPT Frontend Engineer
 * Requires: Three.js, jQuery
 */
(function ($) {
  "use strict";
  /**
   * 建立 ThetaViewer 實例
   * @param {HTMLElement|jQuery} element - 容器元素
   * @param {string} image_url - 全景圖網址
   */
  function createThetaViewer(element, image_url) {
    const $el = $(element);
    const container = $el.get(0);
    // === 初始化 Three.js ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
  const renderer = new THREE.WebGLRenderer({ antialias: true });
    if (renderer.setPixelRatio) {
      renderer.setPixelRatio(window.devicePixelRatio);
    }
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.innerHTML = "";
    container.appendChild(renderer.domElement);
    // === 建立球體全景貼圖 ===
    const loader = new THREE.TextureLoader();
    loader.setCrossOrigin("anonymous");
    loader.load(
      image_url,
      (texture) => {
        texture.generateMipmaps = false;
        texture.minFilter = THREE.LinearFilter;
      const geometry = new THREE.SphereGeometry(500, 60, 40);
      if (geometry.scale) {
        // 新版 three.js
        geometry.scale(-1, 1, 1);
      } else if (geometry.applyMatrix) {
        // 舊版 three.js
        geometry.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));
      }
        const material = new THREE.MeshBasicMaterial({ map: texture });
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);
        camera.position.set(0, 0, 0);
        animate();
      },
      undefined,
      (err) => {
        console.error("圖片載入失敗：", image_url, err);
        alert("圖片載入失敗：" + image_url);
      }
    );
    // === 視窗縮放 ===
    window.addEventListener("resize", () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
    // === 滑動互動控制 ===
    // === 滑動互動控制（兼容 pointer 和 touch） ===
let isDragging = false;
let lon = 0,
  lat = 0,
  phi = 0,
  theta = 0;
let startX = 0,
  startY = 0;

function getEventClientX(e) {
  return e.clientX !== undefined ? e.clientX : (e.touches ? e.touches[0].clientX : 0);
}
function getEventClientY(e) {
  return e.clientY !== undefined ? e.clientY : (e.touches ? e.touches[0].clientY : 0);
}

function onPointerDown(e) {
  isDragging = true;
  startX = getEventClientX(e);
  startY = getEventClientY(e);
  if (e.pointerId && container.setPointerCapture) container.setPointerCapture(e.pointerId);
}
function onPointerMove(e) {
  if (!isDragging) return;
  e.preventDefault(); // 防止頁面滾動等預設行為
  const dx = getEventClientX(e) - startX;
  const dy = getEventClientY(e) - startY;
  startX = getEventClientX(e);
  startY = getEventClientY(e);
  lon -= dx * 0.1;
  lat += dy * 0.1;
  lat = Math.max(-85, Math.min(85, lat));
}
function onPointerUp(e) {
  isDragging = false;
  if (e.pointerId && container.releasePointerCapture) container.releasePointerCapture(e.pointerId);
}

container.addEventListener("pointerdown", onPointerDown);
container.addEventListener("pointermove", onPointerMove);
container.addEventListener("pointerup", onPointerUp);
container.addEventListener("pointercancel", onPointerUp);

// touch event fallback，增加兼容性
container.addEventListener("touchstart", onPointerDown, { passive: false });
container.addEventListener("touchmove", onPointerMove, { passive: false });
container.addEventListener("touchend", onPointerUp);
container.addEventListener("touchcancel", onPointerUp);

    // === 滾輪縮放 ===
    container.addEventListener("wheel", (e) => {
      e.preventDefault();
      camera.fov += e.deltaY * 0.05;
      camera.fov = Math.max(30, Math.min(100, camera.fov));
      camera.updateProjectionMatrix();
    });
    // === 動畫循環 ===
    function animate() {
      requestAnimationFrame(animate);
      const degToRad = (THREE.MathUtils && THREE.MathUtils.degToRad) || THREE.Math.degToRad;
      phi = degToRad(90 - lat);
      theta = degToRad(lon);
      const x = Math.sin(phi) * Math.cos(theta);
      const y = Math.cos(phi);
      const z = Math.sin(phi) * Math.sin(theta);
      camera.lookAt(new THREE.Vector3(x, y, z));
      renderer.render(scene, camera);
    }
  }
  // === jQuery 插件包裝 ===
  $.fn.createThetaViewer = function (image_url) {
    return this.each(function () {
      createThetaViewer(this, image_url);
    });
  };
})(jQuery);
